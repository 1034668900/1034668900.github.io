import{_ as i,p as o,q as l,a1 as r}from"./framework-6700cb35.js";const s="/images/jiwang/terminal-connect.png",n="/assets/terminal-connect2-d659734b.png",t="/images/jiwang/IPxieyi.png",e="/images/jiwang/TCP格式.png",g="/images/jiwang/TCP-connect.png",a="/images/jiwang/TCP-unConnect.png",d="/images/jiwang/App-xieyi.png",h="/images/jiwang/DNS.png",c="/images/jiwang/DNS-cengci.png",p="/images/jiwang/DNS-chaxun.png",u="/images/jiwang/DNS-chaxun-diedai.png",T={},P=r('<h1 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h1><h2 id="osi-rm-基本参考模型-由iso国际标准化组织制定" tabindex="-1"><a class="header-anchor" href="#osi-rm-基本参考模型-由iso国际标准化组织制定" aria-hidden="true">#</a> OSI/RM 基本参考模型（由ISO国际标准化组织制定）</h2><ul><li><strong>应用层</strong>（Application） -- 最高层（第7层）</li><li><strong>表示层</strong>（Presentation）</li><li><strong>会话层</strong>（Session）</li><li><strong>传输层</strong>（Transport）</li><li><strong>网络层</strong>（NetWork）</li><li><strong>数据链路层</strong>（DataLink）</li><li><strong>物理层</strong>（Physical） -- 最底层（第1层）</li></ul><img src="'+s+'" alt="终端连接" style="zoom:50%;"><ul><li>数据封装过程（解封装过程正好相反）</li></ul><img src="'+n+'" alt="数据封装过程" style="zoom:50%;"><h2 id="物理层-physical" tabindex="-1"><a class="header-anchor" href="#物理层-physical" aria-hidden="true">#</a> 物理层（Physical）</h2><h3 id="目的" tabindex="-1"><a class="header-anchor" href="#目的" aria-hidden="true">#</a> 目的</h3><ul><li>保证原始数据<strong>比特流</strong>的无误传输</li></ul><h3 id="任务" tabindex="-1"><a class="header-anchor" href="#任务" aria-hidden="true">#</a> 任务</h3><ul><li>确定与物理媒体相关的<strong>电气特性</strong>、<strong>机械特性</strong>、<strong>功能特性</strong>及<strong>规程特性</strong><ol><li>机械特性：连接器的形式与插针分配</li><li>电气特性：接口电气信号特性</li><li>功能特性：数据传送、控制、定时、接地</li><li>规程特性：接口电路所使用的<strong>规程</strong>(规定多长的高低电平表示多少个1、0)</li></ol></li></ul><h3 id="带宽" tabindex="-1"><a class="header-anchor" href="#带宽" aria-hidden="true">#</a> 带宽</h3><ul><li><strong>带宽定义</strong>：每秒钟传输的数字比特<code>bit</code></li><li><strong>下载速率</strong>：每秒钟传输的<code>字节数</code></li><li>带宽的单位：bps(比特率),即 <code>bit/sec</code></li><li><strong>注意</strong>：带宽的单位和文件的单位不同。 <ol><li><strong>带宽的大小</strong>：指的是<code>每秒能吞吐多少个位</code>(0/1)</li><li><strong>文件的大小</strong>：指的是<code>1字节 = 8位(bit)</code> (8个0/1)</li></ol></li><li><strong>网络距离与带宽</strong><ul><li>距离与带宽成<strong>反比</strong>，距离越远，带宽越低</li><li>因此：局域网的带宽比广域网大</li></ul></li></ul><h3 id="设备" tabindex="-1"><a class="header-anchor" href="#设备" aria-hidden="true">#</a> 设备</h3><ul><li>线路（网线、光纤、无线、同轴电缆）、网卡</li><li><strong>双绞线</strong>可以降低两根线上生成的<strong>磁场</strong>对<strong>信号</strong>产生的影响（电信号）</li><li><strong>单模光纤</strong>的<strong>带宽</strong>比<strong>多模光纤</strong>更大（光信号）</li><li><strong>无线：</strong><ul><li>蓝牙（传输速率低、距离短）</li><li>红外（不能有遮挡）</li><li>RFID（射频技术--NFC）</li></ul></li><li><strong>网卡（网络适配器）：</strong><ul><li><strong>功能</strong>： <ol><li>将数字信号进行<code>串/并转换</code>（属于<strong>物理层</strong>的功能）</li><li>地址标识（属于<strong>数据链路层</strong>的功能）</li><li>数据帧的封装和拆卸（属于<strong>数据链路层</strong>的功能）</li></ol></li><li><strong>网卡地址（无法更改）</strong><ul><li>每个网卡都有字节的<code>MAC地址</code>,又叫<strong>网卡地址</strong>，48比特长，0-23位是厂商代码，24-47位是厂商自行分配的地址</li><li><code>ipconfig/all</code>查询所有网卡地址（包括物理地址和IP地址）</li></ul></li></ul></li></ul><h2 id="数据链路层-datalink" tabindex="-1"><a class="header-anchor" href="#数据链路层-datalink" aria-hidden="true">#</a> 数据链路层（DataLink）</h2><h3 id="目的-1" tabindex="-1"><a class="header-anchor" href="#目的-1" aria-hidden="true">#</a> 目的</h3><ul><li>保证<strong>数据</strong>（<code>单位：帧</code>）在物理链路上实现<strong>可靠</strong>的传输 <ol><li>数据的封装和拆卸</li><li>地址标识</li><li>数据校验</li></ol></li></ul><h3 id="设备-1" tabindex="-1"><a class="header-anchor" href="#设备-1" aria-hidden="true">#</a> 设备</h3><ul><li>主要是<strong>交换机</strong></li></ul><h2 id="网络层-network" tabindex="-1"><a class="header-anchor" href="#网络层-network" aria-hidden="true">#</a> 网络层（NetWork）</h2><h3 id="目的-2" tabindex="-1"><a class="header-anchor" href="#目的-2" aria-hidden="true">#</a> 目的</h3><ul><li>实现数据跨网络的链家</li><li>传输单位<code>包</code></li></ul><h3 id="功能" tabindex="-1"><a class="header-anchor" href="#功能" aria-hidden="true">#</a> 功能</h3><ul><li><p><strong>路由选择</strong></p></li><li><p><strong>实现数据跨网络的连接</strong>（网线+交换机+路由器）</p></li><li><p><strong>IP协议</strong></p><ul><li>图示</li></ul><img src="'+t+'" alt="IP协议" style="zoom:80%;"><ul><li><strong>Ping命令</strong>：使用ICMP协议，可以查看网络连接是否正常 <ul><li>使用：<code>ping address</code></li><li>参数： <ul><li><code>-t </code> 一直ping下去，只有手动停止</li><li><code>-l 数据包大小 </code> 指定数据包大小</li></ul></li><li>ping不通的原因： <ol><li>线路松动或者断开</li><li>网卡问题：网卡坏了、网卡驱动问题</li><li>IP地址问题：地址错误、或者不在同一网络中，并且没有路由等</li></ol></li></ul></li></ul></li><li><p><strong>IP地址</strong></p><ul><li><strong>IPv4地址</strong>由<code>32位</code>二进制数字组成，通常将每八位转换为十进制展示（192.168.0.1),范围为<code>0-255</code>，255是广播地址、0表示网段</li><li><strong>IP地址</strong>由<strong>网络号</strong>和<strong>主机号</strong>组成(<code>各16位</code>)</li><li><strong>网络号</strong> = <strong>IP</strong> 与 <strong>子网掩码</strong> (以<strong>二进制</strong>运算)</li></ul></li><li><p><strong>物理层+数据链路层+网络层：实现数据从源主机的网卡 送到 目标主机的网卡中</strong></p></li><li><p><strong>物理层+数据链路层+网络层+传输层：实现数据从源主机的进程 送到 目标主机的应用进程</strong>（端口号）</p></li></ul><h2 id="传输层-transport" tabindex="-1"><a class="header-anchor" href="#传输层-transport" aria-hidden="true">#</a> 传输层（Transport）</h2><h3 id="目的-3" tabindex="-1"><a class="header-anchor" href="#目的-3" aria-hidden="true">#</a> 目的</h3><ul><li>实现数据从源进程到目标主机进程的传输</li><li>断点续传</li><li>拥塞控制</li></ul><h3 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h3><ul><li><p><strong>UDP</strong>协议</p><ul><li>用户数据报协议</li><li>不可靠的、无连接的协议</li><li>传输效率高</li><li>没有流控机制，只有校验和来提供差错控制（需要上层协议来提供差错控制-例如：TFTP协议）</li></ul></li><li><p><strong>TCP</strong>协议</p><ul><li><p>传输控制协议</p></li><li><p>可靠的、面向连接的协议</p></li><li><p>传输效率低</p></li></ul></li><li><p>UDP和TCP协议的区别：</p><ol><li>UDP是<strong>无连接</strong>的协议，TCP是<strong>面向连接</strong>的协议</li><li>TCP比UDP协议更可靠</li><li>UDP比TCP相比要占用的网络开销小很多，更经济</li></ol></li><li><p><strong>TCP段的格式</strong></p><ul><li><p><strong>源端口</strong>和<strong>目标端口</strong></p></li><li><p><strong>序号</strong>(<code>占4个字节</code>)（sequence number）：数据段的号码</p></li><li><p><strong>确认序号</strong>(<code>占4个字节</code>)（ack number）：确认序号 = 收到的数据的序号 + 1</p><ul><li>表示对方可以发送下一个数据的序列号</li><li>ACK 是否确认消息：<code>1:确认消息 0：非确认消息</code></li></ul></li><li><p><strong>SYN</strong>: 发送给对方的第一个消息</p></li><li><p><strong>FIN</strong>：发送给对方的最后一个消息</p></li><li><p>图示：</p><img src="'+e+'" alt="TCP图示" style="zoom:80%;"></li></ul></li></ul><h3 id="tcp连接-三次握手" tabindex="-1"><a class="header-anchor" href="#tcp连接-三次握手" aria-hidden="true">#</a> TCP连接-三次握手</h3><ul><li><p><strong>主机A</strong>向<strong>主机B</strong>发送<code>SYN</code>，请求建立连接</p></li><li><p><strong>主机B</strong>向<strong>主机A</strong>发送<code>SYN、ACK=1</code>,表示同意建立连接，并请求与主机A建立连接</p></li><li><p><strong>主机A</strong>向<strong>主机B</strong>发送<code>ACK=1</code>,表示同意建立连接，至此三次握手完成</p><img src="'+g+'" alt="TCP连接" style="zoom:80%;"></li></ul><h3 id="tcp连接-四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp连接-四次挥手" aria-hidden="true">#</a> TCP连接-四次挥手</h3><ul><li><p><strong>主机A</strong>向<strong>主机B</strong>发送<code>FIN=1</code>，表示数据传输完毕，请求断开连接</p></li><li><p><strong>主机B</strong>向<strong>主机A</strong>发送<code>ACK=1</code>，表示收到该次请求，但此时数据可能还没接收完</p></li><li><p><strong>主机B</strong>向<strong>主机A</strong>发送<code>FIN=1</code>,表示数据接收完毕，请求断开连接</p></li><li><p><strong>主机A</strong>向<strong>主机B</strong>发送<code>ACK=1</code>，同意断开连接, 至此四次挥手完成</p><img src="'+a+'" alt="TCP连接-四次挥手" style="zoom:80%;"></li></ul><h2 id="应用层-application" tabindex="-1"><a class="header-anchor" href="#应用层-application" aria-hidden="true">#</a> 应用层（Application）</h2><ul><li>决定数据传输格式、是否加密、压缩等</li></ul><h2 id="应用层-tcp-ip协议栈" tabindex="-1"><a class="header-anchor" href="#应用层-tcp-ip协议栈" aria-hidden="true">#</a> 应用层-TCP/IP协议栈</h2><ul><li><p>图示</p><img src="'+d+'" style="zoom:80%;"></li></ul><h2 id="应用层常见协议" tabindex="-1"><a class="header-anchor" href="#应用层常见协议" aria-hidden="true">#</a> 应用层常见协议</h2><h3 id="http协议-hypertext-transfer-protocol-超文本传输协议" tabindex="-1"><a class="header-anchor" href="#http协议-hypertext-transfer-protocol-超文本传输协议" aria-hidden="true">#</a> HTTP协议（HyperText Transfer Protocol）超文本传输协议</h3><ul><li><p>请求响应式协议，请求和响应有固定的格式</p><ul><li><strong>请求格式</strong>： <ul><li><strong>请求行</strong>：用来说明请求类型,要访问的资源以及所使用的HTTP版本。GET说明请求类型为GET，最后一部分说明使用的是HTTP1.1版本。</li></ul></li><li><strong>请求头</strong>：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息，从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 <ul><li><strong>空行</strong>：请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须有空行。</li><li><strong>请求体</strong>：可以添加任意的其他数据</li></ul></li><li><strong>响应格式</strong>：<strong>响应行</strong>、<strong>响应头</strong>、<strong>空行</strong>、<strong>响应体</strong></li></ul></li><li><p>请求方式</p><ul><li>get</li><li>post</li><li>delete</li><li>patch</li><li>...</li></ul></li><li><p>请求响应状态码</p><ul><li>1xx 通常表示正在处理中、处理未完成</li><li>2xx 通常表示<strong>正常</strong>返回</li><li>3xx 通常表示<strong>重定向</strong></li><li>4xx 通常表示<strong>客户端</strong>错误</li><li>5XX 通常表示<strong>服务器</strong>错误</li></ul></li></ul><h3 id="dns协议-domain-name-system-域名服务系统" tabindex="-1"><a class="header-anchor" href="#dns协议-domain-name-system-域名服务系统" aria-hidden="true">#</a> DNS协议（Domain Name System）域名服务系统</h3><ul><li><p>DNS域名系统，用于<strong>TCP/IP网络</strong>，是和HTTP一样位于<strong>应用层</strong>的协议，它所提供的服务是用来<strong>将主机名和域名转换为IP地址</strong>的工作。</p></li><li><p>域名介绍：</p><ul><li>每台服务器都会有一个自己<strong>特有</strong>的标识来和其它服务器区分，这就是IP地址(例如192.168.0.1) ，因此我们访问服务器时都是通过<strong>IP地址</strong>来访问的，但是我们可以看到IP地址极其不利于记忆，因此后面推出了域名，它相当于是服务器的别名，因此访问服务器时我们可以通过域名来访问，但是最终访问服务器的本质还是将域名进行DNS解析，然后通过ip地址来访问的</li></ul></li><li><p>DNS工作图示</p><img src="'+h+'" style="zoom:80%;"></li><li><p>DNS层次结构图示</p><img src="'+c+'" style="zoom:80%;"></li><li><p>DNS递归查询图示</p><p><img src="'+p+'" alt="DNS递归查询图示"></p></li><li><p>DNS迭代查询图示</p><p><img src="'+u+'" alt="DNS迭代查询图示"></p></li></ul><h2 id="http1-1和http2-0的特点" tabindex="-1"><a class="header-anchor" href="#http1-1和http2-0的特点" aria-hidden="true">#</a> HTTP1.1和HTTP2.0的特点</h2><ul><li><p>HTTP1.1</p><ul><li>默认<strong>持久连接</strong>节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求 。</li><li>管线化，客户端可以<strong>同时发出多个HTTP请求</strong>，而不用一个个等待响应 。</li><li><strong>断点续传</strong>，就是可以将一个大数据，分段传输，客户端可以慢慢显示</li></ul></li><li><p>HTTP2.0</p><ul><li>HTTP2.0 采用<strong>二进制格式</strong>而非文本格式</li><li>HTTP2.0 是<strong>完全多路复用</strong>的，而非有序并阻塞的——只需一个HTTP连接就可以实现多个请求响应</li><li>使用<strong>报头压缩</strong>，HTTP2.0 降低了开销</li><li>HTTP2.0 让<strong>服务器</strong>可以将响应<strong>主动</strong>“<strong>推送</strong>”到<strong>客户端缓存中</strong></li></ul></li></ul><h2 id="cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#cookie和session的区别" aria-hidden="true">#</a> Cookie和Session的区别</h2><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> Cookie</h3><ul><li><p><strong>情景说明</strong>：</p><ul><li>HTTP协议是<strong>无状态协议</strong>，它不对之前发生过的请求和响应的状态进行管理。也就是说，<strong>无法根据之前的状态进行本次的请求处理</strong>。假设登录认证的Web页面本身无法进行状态的管理(即不记录已登录状态)，那么每次跳转刷新页面的话<strong>不是要</strong>再次登录，<strong>就是要</strong>在每次请求的报文中附加参数来管理登录状态了。</li><li>当然，<strong>无状态协议</strong>也有它<strong>的优点</strong>，由于<strong>不必保存状态</strong>，自然而然的<strong>减少了服务器的CPU和内存资源</strong>，也正是因为<strong>无状态协议的优点</strong>才使得HTTP协议被广泛应用，那么<strong>如何实现即保留无状态协议、又要解决类似的矛盾问题就成为了一个非常重要的问题</strong>，在这样的背景下，<strong>Cookie技术</strong>诞生了！</li></ul></li><li><p>Cookie技术<strong>通过在请求和响应报文中写入Cookie信息来控制客户端的状态</strong>。</p><ol><li><p>它会根据从服务器发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存Cookie。</p></li><li><p>当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p></li><li><p>服务器端发现客户端发送过来的Cookie后，会检查究竟是从哪一个客户端发送来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p></li></ol></li></ul><h3 id="session" tabindex="-1"><a class="header-anchor" href="#session" aria-hidden="true">#</a> Session</h3><ul><li><strong>Cookie是客户端自己保存用户信息的一种机制</strong>，而<strong>Session却是将先前的用户信息记录在服务器端</strong>，并且生成一个唯一的<strong>Session-ID</strong>,这样一来客户端在每次访问时就仅仅只需提供对应的ID号码便可从服务器获取先前存储的对应信息</li><li><strong>Session的典型应用场景</strong>： <ul><li>以<strong>购物车场景</strong>为例，当用户点击下单按钮时，由于HTTP是<strong>无状态协议</strong>，所以它并不知道是哪个用户在操作，所以服务器要为<strong>特定的用户</strong>创建了<strong>特定的Session</strong>，用于<strong>标识这个用户，并同时跟踪用户</strong>，这样才能保存当前用户的购物信息。而这个Session是存储在<strong>服务器</strong>的，有一个<strong>唯一的Session-ID</strong>与之对应。</li></ul></li><li><strong>服务器保存Session的手段</strong>: <ul><li>服务器可以将Session保存在内存、数据库、文件等等。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，会使用一些缓存服务比如Memcached之类的来存放Session</li></ul></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li>cookie数据存放在客户的浏览器上，session数据存放在服务器上</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie</li><li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K</li></ul><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2><ul><li>HTTPS就是安全的HTTP，在http与传输层之间加上了一个SSL对称加密与非对称加密。HTTPS = HTTP+ 加密 + 认证 + 完整性保护</li></ul><h2 id="浏览器中输入一个url发生什么" tabindex="-1"><a class="header-anchor" href="#浏览器中输入一个url发生什么" aria-hidden="true">#</a> 浏览器中输入一个URL发生什么?</h2><ul><li>输入URL： http://www.taobao.com</li><li><strong>DNS域名解析</strong>，获取到域名对应的<strong>IP地址</strong>和<strong>端口号</strong></li><li><strong>建立TCP/IP连接</strong>(三次握手)</li><li>将用户输入的<strong>URL地址封装到请求报文中</strong>发送到服务器</li><li>服务器将<strong>请求的结果封装到响应报文中</strong>发送到客户端</li><li><strong>客户端接收到响应数据后开始渲染页面</strong>(解析HTML、CSS、执行JS代码)</li></ul>',56),m=[P];function x(S,_){return o(),l("div",null,m)}const C=i(T,[["render",x],["__file","计算机网络.html.vue"]]);export{C as default};
