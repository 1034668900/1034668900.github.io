import{_ as t,p as e,q as o,R as n,t as l,v as s,a1 as i}from"./framework-6700cb35.js";const r="/images/vue2/MVVM.png",u="/images/vue2/DiffImg.png",d={},c=n("h2",{id:"模板语法",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#模板语法","aria-hidden":"true"},"#"),l(" 模板语法")],-1),p={id:"mastach语法-插值语法",tabindex:"-1"},g=n("a",{class:"header-anchor",href:"#mastach语法-插值语法","aria-hidden":"true"},"#",-1),h=i('<ul><li><code>{{ }}</code>内部只能书写<strong>js表达式语句</strong></li><li>表达式： 一个表达式会生成一个值，可以放在一个任何需要值的地方 <ol><li>a --&gt;值本身也是表达式</li><li>a+b --&gt; 运算表达式</li><li>foo( ) --&gt; 函数调用表达式</li><li>条件 ? 结果1 ： 结果2 --&gt; 三元表达式</li></ol></li><li>使用场景 <ul><li>在标签体内解析内容，可以直接读取到data中的所有属性</li><li><strong>其实模板语法中可以使用实例对象vm中的所有属性，以及Vue原型上的所有属性在模板中都能使用</strong></li></ul></li></ul><h2 id="指令语法" tabindex="-1"><a class="header-anchor" href="#指令语法" aria-hidden="true">#</a> 指令语法</h2>',2),v=i("<li><p><strong>v-bind</strong></p><ol><li>使用格式： v-bind:属性名 = “属性值” --&gt; 简写为 :属性名 --&gt; 实现动态绑定属性</li><li>使用场景 <ol><li>用于解析标签(包括： 标签属性、标签体内容、绑定事件......)</li><li>属性值也得是表达式</li><li>单向绑定(data 中的内容改变会影响使用处的内容跟着改变）</li></ol></li></ol></li><li><p><strong>v-on</strong></p><ol><li>使用格式： v-on:事件名 --&gt; 简写 @</li><li>使用场景 --&gt; 用于绑定事件</li></ol></li>",2),m=n("p",null,[n("strong",null,"v-text")],-1),b=n("li",null,[n("strong",null,"作用"),l("：向其所在的节点中渲染文本内容")],-1),k=n("strong",null,"与差值语法的区别",-1),f=n("p",null,[n("strong",null,"v-html")],-1),x=n("li",null,[n("p",null,[n("strong",null,"作用"),l("：向指定节点中渲染包含 html 结构的内容")])],-1),_=n("p",null,[n("strong",null,"与插值语法的区别")],-1),y=n("li",null,"v-html 可以识别 html 结构",-1),V=n("li",null,[n("p",null,[n("strong",null,"注意事项")]),n("ul",null,[n("li",null,[l("v-html的使用有安全问题 "),n("ul",null,[n("li",null,"在网站上动态渲染任意 HTML 是非常危险的，容易导致 XSS 攻击"),n("li",null,"一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上")])])])],-1),w=i("<li><p><strong>v-cloak</strong></p><ul><li>特点：该指令没有值</li><li>本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性</li><li>使用 css 配合 v-cloak 可以解决网速慢时页面展示出 <code>{{xxx}}</code> 的问题</li></ul></li><li><p><strong>v-once</strong></p><ul><li>v-once 所在节点在初次动态渲染后，就视为静态内容了</li><li>以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能</li></ul></li><li><p><strong>v-pre</strong></p><ul><li>跳过其所在节点的编译过程</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li></ul></li>",3),M=i(`<h2 id="数据绑定" tabindex="-1"><a class="header-anchor" href="#数据绑定" aria-hidden="true">#</a> 数据绑定</h2><h3 id="单向数据绑定" tabindex="-1"><a class="header-anchor" href="#单向数据绑定" aria-hidden="true">#</a> 单向数据绑定</h3><ul><li><strong>v-bind</strong><ul><li>实现的是单向绑定,数据只能从data流向页面即<strong>单向数据流</strong>。</li></ul></li></ul><h3 id="双向数据绑定" tabindex="-1"><a class="header-anchor" href="#双向数据绑定" aria-hidden="true">#</a> 双向数据绑定</h3><ul><li><strong>v-model</strong><ul><li>实现的是双向数据绑定,数据可以<strong>双向流动</strong></li><li>双向数据绑定一般都应用在表单类元素（如：input、select等）</li><li><code>v-model:value</code> 可以简写为 v-model,因为v-model默认收集的就是value值。</li></ul></li></ul><h2 id="el和data的两种写法" tabindex="-1"><a class="header-anchor" href="#el和data的两种写法" aria-hidden="true">#</a> el和data的两种写法</h2><h3 id="写法一" tabindex="-1"><a class="header-anchor" href="#写法一" aria-hidden="true">#</a> 写法一</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
	el: <span class="token string">&#39;#root&#39;</span>,
	// data的对象式写法
	data:<span class="token punctuation">{</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="写法二" tabindex="-1"><a class="header-anchor" href="#写法二" aria-hidden="true">#</a> 写法二</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const vm = new Vue({
// data的函数式写法 --&gt; 别用箭头函数，会有this指向问题
	data: function(){
		return{
		// 想要的对象
		}
	}
// 函数式写法简写
	data(){
	return {
	// 想要的对象
	}
	}
})
// el的写法二
vm.$mount(&#39;#root&#39;) // 在实例对象vm上挂载目标容器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li><strong>由Vue管理的函数一定不要使用箭头函数,箭头函数的this指向的是全局window</strong></li></ul><h2 id="mvvm-模型" tabindex="-1"><a class="header-anchor" href="#mvvm-模型" aria-hidden="true">#</a> MVVM 模型</h2><ul><li>M <strong>模型</strong>(Model) : 对应data中的数据</li><li>V <strong>视图</strong>(View) : 模板</li><li>VM <strong>视图模型</strong>(ViewModel) : Vue实例对象 <img src="`+r+`" alt=""></li></ul><h2 id="js-小知识点补充" tabindex="-1"><a class="header-anchor" href="#js-小知识点补充" aria-hidden="true">#</a> JS 小知识点补充</h2><ul><li><strong>defineproperty(obj, property, 配置项{})</strong><ul><li><strong>用于给对象定义属性</strong><ol><li>参数一 绑定属性的目标对象</li><li>参数二 绑定的属性名</li><li>参数三 配置对象</li></ol></li><li><strong>配置对象的属性</strong><ol><li>value 设置属性默认值</li><li>writable 设置属性数否能够修改</li><li>enumerable 设置属性是否可，<strong>枚举</strong>(即是否可遍历)</li><li>configurable 设置属性是否可删除或编辑</li><li>在该函数内部可以书写<strong>getter</strong>和<strong>setter</strong></li></ol></li></ul></li></ul><h2 id="数据代理" tabindex="-1"><a class="header-anchor" href="#数据代理" aria-hidden="true">#</a> 数据代理</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><ul><li>通过一个对象代理对另一个对象中属性的操作(读/写)</li><li>在Vue2中数据代理是通过defineproperty来实现的</li><li>一旦data中的数据发生改变，页面中所有用到该数据的地方都会跟着改变</li></ul><h3 id="数据代理的好处" tabindex="-1"><a class="header-anchor" href="#数据代理的好处" aria-hidden="true">#</a> 数据代理的好处</h3><ul><li>更加方便的操作data中的数据</li></ul><h3 id="vue2数据代理实现示例" tabindex="-1"><a class="header-anchor" href="#vue2数据代理实现示例" aria-hidden="true">#</a> Vue2数据代理实现示例</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>// 实现：通过obj2来代理obj中的x属性
	<span class="token builtin class-name">let</span> obj <span class="token operator">=</span>  <span class="token punctuation">{</span>x <span class="token builtin class-name">:</span> <span class="token number">100</span><span class="token punctuation">}</span>
	<span class="token builtin class-name">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> y <span class="token builtin class-name">:</span> <span class="token number">200</span><span class="token punctuation">}</span>
	
	Object.defineProperty<span class="token punctuation">(</span>obj2, <span class="token string">&#39;x&#39;</span>, <span class="token punctuation">{</span>
		<span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token builtin class-name">return</span> obj.x
		<span class="token punctuation">}</span>,
	// setter中可以接收到属性修改值
		set<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
		obj.x <span class="token operator">=</span> value
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="事件修饰符" tabindex="-1"><a class="header-anchor" href="#事件修饰符" aria-hidden="true">#</a> 事件修饰符</h2><ul><li>使用格式 <strong>@click.stop</strong><ul><li><strong>prevent</strong>： 阻止默认事件(常用)</li><li><strong>stop</strong> ： 阻止事件冒泡(常用)</li><li><strong>once</strong>：事件只触发一次(常用)</li><li><strong>capture</strong>：使用事件的捕获模式</li><li><strong>self</strong>：只有event.target是当前操作的元素时才触发事件</li><li><strong>passive</strong>：事件的默认行为立即执行，无需等待事件回调完毕</li></ul></li></ul><h2 id="键盘事件" tabindex="-1"><a class="header-anchor" href="#键盘事件" aria-hidden="true">#</a> 键盘事件</h2><ul><li><p><strong>Keydown</strong>和 <strong>Keyup</strong></p></li><li><p>使用格式</p><ul><li>@<strong>keyup</strong>.键名</li><li>@<strong>keydown</strong>.键名(键码 <strong>不推荐</strong>)</li></ul></li><li><p>Vue中<strong>常用按键别名</strong></p><ul><li><strong>enter</strong><ul><li>回车</li></ul></li><li><strong>delete</strong><ul><li>删除(退格)</li></ul></li><li><strong>esc</strong><ul><li>退出</li></ul></li><li><strong>space</strong><ul><li>空格</li></ul></li><li><strong>tab</strong><ul><li>换行(只能配合Keydown键使用，因为Keyup该元素已经失去焦点，无法再响应对应事件)</li></ul></li><li><strong>up</strong><ul><li>上</li></ul></li><li><strong>down</strong><ul><li>下</li></ul></li><li><strong>left</strong><ul><li>左</li></ul></li><li><strong>right</strong><ul><li>右</li></ul></li></ul></li><li><p>对于Vue未提供别名的按键，可以使用按键原始的key去绑定，但是要注意转为kebab-case(短横线命名)</p><ul><li>Vue.config.key <ul><li>获取对应按键的key</li></ul></li><li>Vue.config.keycodes <ul><li>获取对应按键的codes编码</li></ul></li></ul></li><li><p><strong>系统修饰按键</strong>(用法<strong>特殊</strong>): ctrl 、 alt 、 shift 、 meta (win键)</p><ul><li>配合Keyup使用 <ul><li>按下按键的同时，再按下其它键，接着释放其它按键，事件才会被触发</li></ul></li><li>配合Keydown使用 <ul><li>正常触发事件</li></ul></li></ul></li><li><p>可以使用KeyCode去指定具体按键(<strong>不推荐</strong>)</p></li><li><p><strong>自定义按键别名</strong></p><ul><li>Vue.config.keyCodes.自定义键名 = 键码</li></ul></li></ul><h2 id="计算属性-computed" tabindex="-1"><a class="header-anchor" href="#计算属性-computed" aria-hidden="true">#</a> 计算属性(computed)</h2><ul><li><strong>定义</strong><ul><li>要使用的属性不存在，需要通过已有属性计算得来</li></ul></li><li><strong>原理</strong><ul><li>底层借助了<strong>Object.defineProperty</strong>方法提供的<strong>getter</strong>和<strong>setter</strong></li></ul></li><li><strong>get函数什么时候执行？</strong><ol><li>初次读取该属性时会执行一次</li><li>当依赖的数据发生改变时会被再次调用</li></ol></li><li><strong>和methods比computed有什么优势？</strong><ul><li>computed内部有缓存机制(复用),效率更高，调试方便</li></ul></li><li><strong>补充</strong><ol><li>计算属性最终会出现在实例对象vm上，使用时可直接读取</li><li>如果计算属性要被修改，那么必须写<strong>set</strong>函数去响应修改，且<strong>set</strong>中要引起计算属性所<strong>依赖</strong>的数据发生变换</li><li>如果计算属性确定不考虑修改，则可以使用计算属性的简写形式</li><li>再页面中可以使用插值语法<code>{{**计算属性名**}}</code>来显示计算结果</li></ol></li><li><strong>计算属性的简写(不考虑修改才能简写)</strong></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>	// 完整写法<span class="token punctuation">(</span>计算属性要写成配置对象<span class="token punctuation">)</span>
	计算属性名: <span class="token punctuation">{</span>
		<span class="token function-name function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token punctuation">}</span>,
	// set按需写
		<span class="token function-name function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	// 简写<span class="token punctuation">(</span>不考虑修改<span class="token punctuation">)</span>
	计算属性名: <span class="token function-name function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	// 这个函数会被作为get函数使用
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="监视属性-watch" tabindex="-1"><a class="header-anchor" href="#监视属性-watch" aria-hidden="true">#</a> 监视属性(watch)</h2><ul><li><strong>监视属性watch</strong><ol><li>当被监视的属性变化时，<strong>回调函数自动调用</strong>，进行相关操作</li><li><strong>监视的属性必须存在</strong>，才能进行监视</li><li>监视的两种写法 <ol><li>new Vue时传入watch配置</li><li>通过vm.$watch监视</li></ol></li></ol></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>	new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>
	el: <span class="token string">&quot;#root&quot;</span>,
	data: <span class="token punctuation">{</span><span class="token punctuation">}</span>,
	watch: <span class="token punctuation">{</span>
		监视属性:<span class="token punctuation">{</span>
			immediate: false/true， // 初始化时handler是否执行
			handler<span class="token punctuation">(</span>newValue,oldValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
			// 执行语句
			<span class="token punctuation">}</span>
		｝
	<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="计算属性-computed-和监视属性-watch-的区别" tabindex="-1"><a class="header-anchor" href="#计算属性-computed-和监视属性-watch-的区别" aria-hidden="true">#</a> 计算属性(computed)和监视属性(watch)的区别</h2><ul><li>computed能完成的功能，watch都能够完成</li><li>但是watch能完成的功能，computed不一定能完成。(watch可以进行异步操作)</li></ul><h2 id="样式绑定" tabindex="-1"><a class="header-anchor" href="#样式绑定" aria-hidden="true">#</a> 样式绑定</h2><ul><li><strong>class样式</strong><ul><li><strong>写法</strong>： class = &#39;xxx&#39; 其中xxx可以是字符串、对象、数组 <ol><li><strong>字符串写法</strong>：适用于类名不确定，需要动态获取</li><li><strong>对象写法</strong>：使用于要绑定多个样式，个数不确定、名字也不确定</li><li><strong>数组写法</strong>：适用于要绑定多个样式、个数确定、名字也确定，但是不确定用不用</li></ol></li></ul></li><li><strong>style样式</strong><ul><li>:style= &#39;{样式属性: xxx}&#39; 其中xxx是动态值</li><li>:style = &#39;[a, b]&#39; 其中a、b是样式对象</li></ul></li></ul><h2 id="条件渲染" tabindex="-1"><a class="header-anchor" href="#条件渲染" aria-hidden="true">#</a> 条件渲染</h2><ul><li><p><strong>v-if</strong></p><ul><li><strong>适用场景</strong>：切换频率较低</li><li><strong>特点</strong>：不符合if提交的元素直接移除(即无法通过DOM操作获取到元素)</li><li><strong>注意事项</strong>： v-if 和 v-else-if 以及 v-else 一起使用时，要求结构不能被打断</li></ul></li><li><p><strong>v-show</strong></p><ul><li><strong>适用场景</strong>： 切换频率较高的场景</li><li><strong>特点</strong>：利用的是display属性控制元素的隐藏与否</li><li><strong>注意事项</strong>：即使元素被隐藏，也可以通过通过DOM操作获取该元素</li></ul></li></ul><h2 id="列表渲染" tabindex="-1"><a class="header-anchor" href="#列表渲染" aria-hidden="true">#</a> 列表渲染</h2><ul><li><strong>v-for指令</strong><ul><li>适用场景：用于展示列表数据</li><li>用法：v-for = &#39;(item, index) in xxx&#39;</li><li>可以利用v-for指令遍历数组、对象、字符串(非常少)、指定次数遍历(很少)</li></ul></li></ul><h3 id="v-for指令key原理" tabindex="-1"><a class="header-anchor" href="#v-for指令key原理" aria-hidden="true">#</a> v-for指令key原理</h3><ul><li>在使用v-for指令进行遍历时，如果没有指定key值，那么Vue会默认的将遍历时的索引值index作为key</li><li><strong>将index当作key有什么漏洞</strong>？ <ul><li>对列表数据进行破坏顺序的操作的时候，会产生没有必要的真实DOM的更新，如果此时结构中还有输入类的元素时(例如input输入框),此时会出现数据错乱的现象(和Vue的虚拟DOM对比规则有关)</li></ul></li><li><strong>Vue中虚拟DOM对比规则(Diff算法)</strong><ul><li>若在旧的虚拟DOM中找到了与新虚拟DOM中相同的key <ol><li>若虚拟Dom 中的内容没有改变，则直接使用之前的真实DOM</li><li>若虚拟DOM中的内容变化，则生成新的真实DOM，紧接着替换页面中之前的真实DOM</li></ol></li><li>若在旧的虚拟DOM中没有找到与新的虚拟DOM相同的key <ol><li>直接创建新的真实DOM，渲染页面</li></ol></li></ul></li></ul><p><img src="`+u+'" alt="Diff算法"></p><ul><li><strong>以index为key时，为什么在输入框中输入了数据，当进行破坏顺序的操作时数据还是会数据错乱？</strong><ul><li>用户在页面中进行的一切操作，都是在操作真实DOM，包括在输入框中输入内容，因此有内容的是真实DOM，但是在Vue的虚拟DOM中，input输入框是没有内容的，对比后发现相同就会将其进行复用，从而导致数据错乱</li></ul></li><li><strong>开发过程中key的选择</strong><ul><li>最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用 index 作为 key 是没有问题的</li></ul></li></ul>',45);function D(a,O){return e(),o("div",null,[c,n("h3",p,[g,l(" mastach语法 "+s()+" --> 插值语法",1)]),h,n("ul",null,[v,n("li",null,[m,n("ol",null,[b,n("li",null,[k,l("：v-text 会替换掉节点中的内容，"+s(a.xx)+" 则不会",1)])])]),n("li",null,[f,n("ol",null,[x,n("li",null,[_,n("ol",null,[n("li",null,"v-html 会替换掉节点中所有的内容，"+s(a.xx)+" 则不会",1),y])]),V])]),w]),M])}const K=t(d,[["render",D],["__file","Vue2-小节1.html.vue"]]);export{K as default};
